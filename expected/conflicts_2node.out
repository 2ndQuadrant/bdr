\c postgres
--
-- Tests for conflict handling and resolution
--
-- Here we use a common trick of ensuring replication is still working by
-- taking the DDL lock using a DDL statement we then roll back, in case you're
-- wondering why those are there...
--
-- Test Table. Note the presence of the secondary UNIQUE constraint,
-- which we'll be using when testing conflict handling.
CREATE TABLE public.city
( city_sid INTEGER NOT NULL,
  name  VARCHAR,
  CONSTRAINT city_pk PRIMARY KEY (city_sid),
  CONSTRAINT city_un UNIQUE (name)
);
\d+ public.city
                               Table "public.city"
  Column  |       Type        | Modifiers | Storage  | Stats target | Description 
----------+-------------------+-----------+----------+--------------+-------------
 city_sid | integer           | not null  | plain    |              | 
 name     | character varying |           | extended |              | 
Indexes:
    "city_pk" PRIMARY KEY, btree (city_sid)
    "city_un" UNIQUE CONSTRAINT, btree (name)

ALTER TABLE public.city REPLICA IDENTITY DEFAULT;
-- A user defined conflict handler log table we'll be using later
CREATE TYPE public.bdr_nodeid AS (
  sysid text,
  timeline oid,
  dboid oid
);
CREATE SEQUENCE log_seq;
CREATE TABLE public.bdr_log
( nodeid bdr_nodeid not null default ROW((bdr.bdr_get_local_nodeid()).*),
  nodeseq INTEGER NOT NULL default nextval('log_seq'),
  log_info1  VARCHAR,
  log_info2 VARCHAR,
  CONSTRAINT bdr_log_pk PRIMARY KEY (nodeid, nodeseq)
);
-- Now, for this test we need our apply workers to use a replication delay.
ALTER SYSTEM SET bdr.default_apply_delay = 1000;
ALTER SYSTEM SET bdr.log_conflicts_to_table = on;
ALTER SYSTEM SET bdr.conflict_logging_include_tuples = on;
SELECT pg_reload_conf();
 pg_reload_conf 
----------------
 t
(1 row)

SELECT pg_sleep(1);
 pg_sleep 
----------
 
(1 row)

-- Run the suite with default replica identity and no user conflict handler.
\i sql/conflict_cases.sql
\c postgres
-- A bunch of repeatable sub-tests run by other suites.
-- This isn't executed directly by pg_regress as a top-level
-- test so it doesn't need an expected file etc.
--
-- ***Starting conflict_cases.sql run***
-- Cleanup
TRUNCATE TABLE city;
TRUNCATE TABLE bdr_log;
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

TRUNCATE TABLE bdr.bdr_conflict_history;
\c regression
TRUNCATE TABLE bdr.bdr_conflict_history;
\c postgres
---------------------------------------------------
-- Simple insert/insert conflict         
---------------------------------------------------
INSERT INTO city(city_sid, name) VALUES (1, 'Parabadoo');
\c regression
INSERT INTO city(city_sid, name) VALUES (1, 'Newman');
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

SELECT object_schema, object_name, conflict_type, conflict_resolution, local_tuple, remote_tuple FROM bdr.bdr_conflict_history;
 object_schema | object_name | conflict_type |     conflict_resolution     |          local_tuple           |           remote_tuple            
---------------+-------------+---------------+-----------------------------+--------------------------------+-----------------------------------
 public        | city        | insert_insert | last_update_wins_keep_local | {"city_sid":1,"name":"Newman"} | {"city_sid":1,"name":"Parabadoo"}
(1 row)

SELECT * FROM bdr_log;
 nodeid | nodeseq | log_info1 | log_info2 
--------+---------+-----------+-----------
(0 rows)

SELECT * FROM city WHERE city_sid = 1;
 city_sid |  name  
----------+--------
        1 | Newman
(1 row)

\c postgres
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

SELECT object_schema, object_name, conflict_type, conflict_resolution, local_tuple, remote_tuple FROM bdr.bdr_conflict_history;
 object_schema | object_name | conflict_type | conflict_resolution | local_tuple | remote_tuple 
---------------+-------------+---------------+---------------------+-------------+--------------
(0 rows)

SELECT * FROM city WHERE city_sid = 1;
 city_sid |  name  
----------+--------
        1 | Newman
(1 row)

SELECT * FROM bdr_log;
 nodeid | nodeseq | log_info1 | log_info2 
--------+---------+-----------+-----------
(0 rows)

-- Replication still works
BEGIN;
SET LOCAL statement_timeout = '10s';
CREATE TABLE sydney(dummy integer);
ROLLBACK;
---------------------------------------------------
-- Secondary unique index insert/insert conflict
---------------------------------------------------
INSERT INTO city(city_sid, name) VALUES (2, 'Tom Price');
\c regression
INSERT INTO city(city_sid, name) VALUES (3, 'Tom Price');
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

SELECT object_schema, object_name, conflict_type, conflict_resolution, local_tuple, remote_tuple FROM bdr.bdr_conflict_history;
 object_schema | object_name | conflict_type |     conflict_resolution     |            local_tuple            |           remote_tuple            
---------------+-------------+---------------+-----------------------------+-----------------------------------+-----------------------------------
 public        | city        | insert_insert | last_update_wins_keep_local | {"city_sid":1,"name":"Newman"}    | {"city_sid":1,"name":"Parabadoo"}
 public        | city        | insert_insert | last_update_wins_keep_local | {"city_sid":3,"name":"Tom Price"} | {"city_sid":2,"name":"Tom Price"}
(2 rows)

SELECT * FROM bdr_log;
 nodeid | nodeseq | log_info1 | log_info2 
--------+---------+-----------+-----------
(0 rows)

SELECT * FROM city WHERE name = 'Tom Price';
 city_sid |   name    
----------+-----------
        3 | Tom Price
(1 row)

\c postgres
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

SELECT object_schema, object_name, conflict_type, conflict_resolution, local_tuple, remote_tuple FROM bdr.bdr_conflict_history;
 object_schema | object_name | conflict_type | conflict_resolution | local_tuple | remote_tuple 
---------------+-------------+---------------+---------------------+-------------+--------------
(0 rows)

SELECT * FROM bdr_log;
 nodeid | nodeseq | log_info1 | log_info2 
--------+---------+-----------+-----------
(0 rows)

SELECT * FROM city WHERE name = 'Tom Price';
 city_sid |   name    
----------+-----------
        3 | Tom Price
(1 row)

-- We detected the conflict on the secondary index and handled it.
-- Replication still works
BEGIN;
SET LOCAL statement_timeout = '10s';
CREATE TABLE sydney(dummy integer);
ROLLBACK;
---------------------------------------------------
-- Two unique violations insert/insert conflict
---------------------------------------------------
-- TODO
---------------------------------------------------
-- Partial secondary unique index insert/insert conflict
---------------------------------------------------
-- TODO
---------------------------------------------------
-- Expression secondary unique index insert/insert conflict
---------------------------------------------------
-- TODO
---------------------------------------------------
-- Update/Update conflict on normal data change
---------------------------------------------------
INSERT INTO city(city_sid, name) VALUES (10, 'Carnarvon');
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

UPDATE city SET name = 'Dwellingup' WHERE city_sid = 10;
\c regression
UPDATE city SET name = 'Balingup' WHERE city_sid = 10;
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

SELECT object_schema, object_name, conflict_type, conflict_resolution, local_tuple, remote_tuple FROM bdr.bdr_conflict_history;
 object_schema | object_name | conflict_type |     conflict_resolution     |            local_tuple            |            remote_tuple             
---------------+-------------+---------------+-----------------------------+-----------------------------------+-------------------------------------
 public        | city        | insert_insert | last_update_wins_keep_local | {"city_sid":1,"name":"Newman"}    | {"city_sid":1,"name":"Parabadoo"}
 public        | city        | insert_insert | last_update_wins_keep_local | {"city_sid":3,"name":"Tom Price"} | {"city_sid":2,"name":"Tom Price"}
 public        | city        | update_update | last_update_wins_keep_local | {"city_sid":10,"name":"Balingup"} | {"city_sid":10,"name":"Dwellingup"}
(3 rows)

SELECT * FROM bdr_log;
 nodeid | nodeseq | log_info1 | log_info2 
--------+---------+-----------+-----------
(0 rows)

SELECT * FROM city WHERE city_sid IN (10);
 city_sid |   name   
----------+----------
       10 | Balingup
(1 row)

\c postgres
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

SELECT object_schema, object_name, conflict_type, conflict_resolution, local_tuple, remote_tuple FROM bdr.bdr_conflict_history;
 object_schema | object_name | conflict_type | conflict_resolution | local_tuple | remote_tuple 
---------------+-------------+---------------+---------------------+-------------+--------------
(0 rows)

SELECT * FROM bdr_log;
 nodeid | nodeseq | log_info1 | log_info2 
--------+---------+-----------+-----------
(0 rows)

SELECT * FROM city WHERE city_sid IN (10);
 city_sid |   name   
----------+----------
       10 | Balingup
(1 row)

-- No point testing for broken replication here, it can't break anything.
---------------------------------------------------
-- Update/Update conflict on PRIMARY KEY change
---------------------------------------------------
INSERT INTO city(city_sid, name) VALUES (4, 'Exmouth'), (5, 'Coral Bay');
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

UPDATE city SET city_sid = 6 WHERE city_sid = 4;
\c regression
UPDATE city SET city_sid = 6 WHERE city_sid = 5;
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

SELECT object_schema, object_name, conflict_type, conflict_resolution, local_tuple, remote_tuple FROM bdr.bdr_conflict_history;
 object_schema | object_name | conflict_type |     conflict_resolution     |            local_tuple            |            remote_tuple             
---------------+-------------+---------------+-----------------------------+-----------------------------------+-------------------------------------
 public        | city        | insert_insert | last_update_wins_keep_local | {"city_sid":1,"name":"Newman"}    | {"city_sid":1,"name":"Parabadoo"}
 public        | city        | insert_insert | last_update_wins_keep_local | {"city_sid":3,"name":"Tom Price"} | {"city_sid":2,"name":"Tom Price"}
 public        | city        | update_update | last_update_wins_keep_local | {"city_sid":10,"name":"Balingup"} | {"city_sid":10,"name":"Dwellingup"}
(3 rows)

SELECT * FROM bdr_log;
 nodeid | nodeseq | log_info1 | log_info2 
--------+---------+-----------+-----------
(0 rows)

SELECT * FROM city WHERE city_sid IN (4,5,6);
 city_sid |   name    
----------+-----------
        4 | Exmouth
        6 | Coral Bay
(2 rows)

\c postgres
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

SELECT object_schema, object_name, conflict_type, conflict_resolution, local_tuple, remote_tuple FROM bdr.bdr_conflict_history;
 object_schema | object_name | conflict_type | conflict_resolution | local_tuple | remote_tuple 
---------------+-------------+---------------+---------------------+-------------+--------------
(0 rows)

SELECT * FROM bdr_log;
 nodeid | nodeseq | log_info1 | log_info2 
--------+---------+-----------+-----------
(0 rows)

SELECT * FROM city WHERE city_sid IN (4,5,6);
 city_sid |   name    
----------+-----------
        5 | Coral Bay
        6 | Exmouth
(2 rows)

-- Replication broke, oops!
--
-- The logs will report something like:
--
-- ERROR:  duplicate key value violates unique constraint "city_pk"
-- DETAIL:  Key (city_sid)=(6) already exists.
-- CONTEXT:  apply UPDATE from remote relation public.city in commit 0/1B03740, xid 2052 commited at 2016-10-18 06:45:24.693261+00 (action #2) from node (6342692214835298407,1,13104)
--
-- on one or both nodes. Confirm by taking DDL lock:
BEGIN;
SET LOCAL statement_timeout = '10s';
CREATE TABLE sydney(dummy integer);
psql:sql/conflict_cases.sql:133: ERROR:  canceling statement due to statement timeout
ROLLBACK;
-- We can fix this without discarding transactions from the queue by resolving
-- the conflict on one or both sides to allow replication to complete. Simple
-- pg_regress tests can't do things like look at the logs so assume we conflict
-- on both sides.
DELETE FROM city WHERE city_sid = 6;
\c regression
DELETE FROM city WHERE city_sid = 6;
\c postgres
-- When we get the DDL lock we know we've recovered
BEGIN;
SET LOCAL statement_timeout = '10s';
CREATE TABLE sydney(dummy integer);
ROLLBACK;
-- FIXME!
---------------------------------------------------
-- Update/Update conflict on secondary unique index
---------------------------------------------------
-- But what about conflicting UPDATEs that cause violation of a secondary
-- unique index?
UPDATE city SET name = 'Kalgoorlie' WHERE city_sid = 1;
\c regression
UPDATE city SET name = 'Kalgoorlie' WHERE city_sid = 3;
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

SELECT object_schema, object_name, conflict_type, conflict_resolution, local_tuple, remote_tuple FROM bdr.bdr_conflict_history;
 object_schema | object_name | conflict_type |     conflict_resolution     |            local_tuple            |            remote_tuple             
---------------+-------------+---------------+-----------------------------+-----------------------------------+-------------------------------------
 public        | city        | insert_insert | last_update_wins_keep_local | {"city_sid":1,"name":"Newman"}    | {"city_sid":1,"name":"Parabadoo"}
 public        | city        | insert_insert | last_update_wins_keep_local | {"city_sid":3,"name":"Tom Price"} | {"city_sid":2,"name":"Tom Price"}
 public        | city        | update_update | last_update_wins_keep_local | {"city_sid":10,"name":"Balingup"} | {"city_sid":10,"name":"Dwellingup"}
(3 rows)

SELECT * FROM bdr_log;
 nodeid | nodeseq | log_info1 | log_info2 
--------+---------+-----------+-----------
(0 rows)

SELECT * FROM city WHERE city_sid IN (1,3);
 city_sid |    name    
----------+------------
        1 | Newman
        3 | Kalgoorlie
(2 rows)

\c postgres
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

SELECT object_schema, object_name, conflict_type, conflict_resolution, local_tuple, remote_tuple FROM bdr.bdr_conflict_history;
 object_schema | object_name | conflict_type | conflict_resolution | local_tuple | remote_tuple 
---------------+-------------+---------------+---------------------+-------------+--------------
(0 rows)

SELECT * FROM city WHERE city_sid IN (1,3);
 city_sid |    name    
----------+------------
        3 | Tom Price
        1 | Kalgoorlie
(2 rows)

SELECT * FROM bdr_log;
 nodeid | nodeseq | log_info1 | log_info2 
--------+---------+-----------+-----------
(0 rows)

-- ... that seemed to work, after all, pg_xlog_wait_remote_apply returned. But
-- it only returned because there are no walsenders anymore, we'lll be in a crash
-- cycle on one or both nodes and nothing will be replicating.
--
-- Lets try to take the DDL lock, we'll get stuck here.
BEGIN;
SET LOCAL statement_timeout = '10s';
CREATE TABLE sydney(dummy integer);
psql:sql/conflict_cases.sql:179: ERROR:  canceling statement due to statement timeout
ROLLBACK;
-- Output on one or both nodes will be something like:
--
-- ERROR:  duplicate key value violates unique constraint "city_un"
-- DETAIL:  Key (name)=(Kalgoorlie) already exists.
-- CONTEXT:  apply UPDATE from remote relation public.city in commit 0/1B08AA8, xid 2076 commited at 2016-10-18 06:54:14.36732+00 (action #2) from node (6342694436480988016,1 ,16385)
-- To fix it, same deal as before, remove a conflicting row.
DELETE FROM city WHERE name = 'Kalgoorlie';
\c regression
DELETE FROM city WHERE name = 'Kalgoorlie';
\c postgres
BEGIN;
SET LOCAL statement_timeout = '10s';
CREATE TABLE sydney(dummy integer);
ROLLBACK;
-- FIXME!
---------------------------------------------------
-- Two unique violations update/update conflict
---------------------------------------------------
-- TODO
---------------------------------------------------
-- Update/Update conflict on secondary unique expression index
---------------------------------------------------
-- TODO
---------------------------------------------------
-- Update/Update conflict on secondary partial unique index
---------------------------------------------------
-- TODO
---------------------------------------------------
-- Insert/Update conflicts
---------------------------------------------------
-- TODO
--
-- Note that insert/update vs update/delete is ambiguous
-- (might need 3 nodes)
---------------------------------------------------
-- Update/Delete conflicts
---------------------------------------------------
-- TODO
--
-- Note that insert/update vs update/delete is ambiguous
-- (might need 3 nodes)
---------------------------------------------------
-- Delete/Delete "conflicts"
---------------------------------------------------
-- TODO
---------------------------------------------------
-- Insert/Delete conflicts
---------------------------------------------------
-- TODO
-- This probably needs 3 nodes though...
-- *** Ending conflict_cases.sql run ***
-- Rerun with a user conflict handler:
CREATE OR REPLACE FUNCTION public.city_insert_conflict_resolution(
    IN  rec1 public.city,
    IN  rec2 public.city,
    IN  conflict_info text,
    IN  table_name regclass,
    IN  conflict_type bdr.bdr_conflict_type, 
    OUT rec_resolution public.city,
    OUT conflict_action bdr.bdr_conflict_handler_action)
 RETURNS record AS
$BODY$
BEGIN
  INSERT INTO public.bdr_log(log_info1, log_info2) VALUES (rec1::text, rec2::text);
  rec_resolution := rec1;
  conflict_action := 'ROW';
END
$BODY$
 LANGUAGE plpgsql VOLATILE;
SELECT bdr.bdr_create_conflict_handler(
  ch_rel := 'public.city',
  ch_name := 'city_insert_csh',
  ch_proc := 'public.city_insert_conflict_resolution(public.city, public.city, text, regclass, bdr.bdr_conflict_type)',
  ch_type := 'insert_insert'
);
 bdr_create_conflict_handler 
-----------------------------
 
(1 row)

\i sql/conflict_cases.sql
\c postgres
-- A bunch of repeatable sub-tests run by other suites.
-- This isn't executed directly by pg_regress as a top-level
-- test so it doesn't need an expected file etc.
--
-- ***Starting conflict_cases.sql run***
-- Cleanup
TRUNCATE TABLE city;
TRUNCATE TABLE bdr_log;
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

TRUNCATE TABLE bdr.bdr_conflict_history;
\c regression
TRUNCATE TABLE bdr.bdr_conflict_history;
\c postgres
---------------------------------------------------
-- Simple insert/insert conflict         
---------------------------------------------------
INSERT INTO city(city_sid, name) VALUES (1, 'Parabadoo');
\c regression
INSERT INTO city(city_sid, name) VALUES (1, 'Newman');
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

SELECT object_schema, object_name, conflict_type, conflict_resolution, local_tuple, remote_tuple FROM bdr.bdr_conflict_history;
 object_schema | object_name | conflict_type |       conflict_resolution       |          local_tuple           |           remote_tuple            
---------------+-------------+---------------+---------------------------------+--------------------------------+-----------------------------------
 public        | city        | insert_insert | conflict_trigger_returned_tuple | {"city_sid":1,"name":"Newman"} | {"city_sid":1,"name":"Parabadoo"}
(1 row)

SELECT * FROM bdr_log;
            nodeid             | nodeseq | log_info1  |   log_info2   
-------------------------------+---------+------------+---------------
 (6343025451829079416,1,16385) |       1 | (1,Newman) | (1,Parabadoo)
(1 row)

SELECT * FROM city WHERE city_sid = 1;
 city_sid |  name  
----------+--------
        1 | Newman
(1 row)

\c postgres
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

SELECT object_schema, object_name, conflict_type, conflict_resolution, local_tuple, remote_tuple FROM bdr.bdr_conflict_history;
 object_schema | object_name | conflict_type |       conflict_resolution       |            local_tuple            |          remote_tuple          
---------------+-------------+---------------+---------------------------------+-----------------------------------+--------------------------------
 public        | city        | insert_insert | conflict_trigger_returned_tuple | {"city_sid":1,"name":"Parabadoo"} | {"city_sid":1,"name":"Newman"}
(1 row)

SELECT * FROM city WHERE city_sid = 1;
 city_sid |   name    
----------+-----------
        1 | Parabadoo
(1 row)

SELECT * FROM bdr_log;
            nodeid             | nodeseq |   log_info1   | log_info2  
-------------------------------+---------+---------------+------------
 (6343025451829079416,1,13104) |       1 | (1,Parabadoo) | (1,Newman)
(1 row)

-- Replication still works
BEGIN;
SET LOCAL statement_timeout = '10s';
CREATE TABLE sydney(dummy integer);
ROLLBACK;
---------------------------------------------------
-- Secondary unique index insert/insert conflict
---------------------------------------------------
INSERT INTO city(city_sid, name) VALUES (2, 'Tom Price');
\c regression
INSERT INTO city(city_sid, name) VALUES (3, 'Tom Price');
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

SELECT object_schema, object_name, conflict_type, conflict_resolution, local_tuple, remote_tuple FROM bdr.bdr_conflict_history;
 object_schema | object_name | conflict_type |       conflict_resolution       |            local_tuple            |           remote_tuple            
---------------+-------------+---------------+---------------------------------+-----------------------------------+-----------------------------------
 public        | city        | insert_insert | conflict_trigger_returned_tuple | {"city_sid":1,"name":"Newman"}    | {"city_sid":1,"name":"Parabadoo"}
 public        | city        | insert_insert | conflict_trigger_returned_tuple | {"city_sid":3,"name":"Tom Price"} | {"city_sid":2,"name":"Tom Price"}
(2 rows)

SELECT * FROM bdr_log;
            nodeid             | nodeseq |    log_info1    |    log_info2    
-------------------------------+---------+-----------------+-----------------
 (6343025451829079416,1,16385) |       1 | (1,Newman)      | (1,Parabadoo)
 (6343025451829079416,1,16385) |       2 | (3,"Tom Price") | (2,"Tom Price")
(2 rows)

SELECT * FROM city WHERE name = 'Tom Price';
 city_sid |   name    
----------+-----------
        3 | Tom Price
(1 row)

\c postgres
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

SELECT object_schema, object_name, conflict_type, conflict_resolution, local_tuple, remote_tuple FROM bdr.bdr_conflict_history;
 object_schema | object_name | conflict_type |       conflict_resolution       |            local_tuple            |           remote_tuple            
---------------+-------------+---------------+---------------------------------+-----------------------------------+-----------------------------------
 public        | city        | insert_insert | conflict_trigger_returned_tuple | {"city_sid":1,"name":"Parabadoo"} | {"city_sid":1,"name":"Newman"}
 public        | city        | insert_insert | conflict_trigger_returned_tuple | {"city_sid":2,"name":"Tom Price"} | {"city_sid":3,"name":"Tom Price"}
(2 rows)

SELECT * FROM bdr_log;
            nodeid             | nodeseq |    log_info1    |    log_info2    
-------------------------------+---------+-----------------+-----------------
 (6343025451829079416,1,13104) |       1 | (1,Parabadoo)   | (1,Newman)
 (6343025451829079416,1,13104) |       2 | (2,"Tom Price") | (3,"Tom Price")
(2 rows)

SELECT * FROM city WHERE name = 'Tom Price';
 city_sid |   name    
----------+-----------
        2 | Tom Price
(1 row)

-- We detected the conflict on the secondary index and handled it.
-- Replication still works
BEGIN;
SET LOCAL statement_timeout = '10s';
CREATE TABLE sydney(dummy integer);
ROLLBACK;
---------------------------------------------------
-- Two unique violations insert/insert conflict
---------------------------------------------------
-- TODO
---------------------------------------------------
-- Partial secondary unique index insert/insert conflict
---------------------------------------------------
-- TODO
---------------------------------------------------
-- Expression secondary unique index insert/insert conflict
---------------------------------------------------
-- TODO
---------------------------------------------------
-- Update/Update conflict on normal data change
---------------------------------------------------
INSERT INTO city(city_sid, name) VALUES (10, 'Carnarvon');
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

UPDATE city SET name = 'Dwellingup' WHERE city_sid = 10;
\c regression
UPDATE city SET name = 'Balingup' WHERE city_sid = 10;
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

SELECT object_schema, object_name, conflict_type, conflict_resolution, local_tuple, remote_tuple FROM bdr.bdr_conflict_history;
 object_schema | object_name | conflict_type |       conflict_resolution       |            local_tuple            |            remote_tuple             
---------------+-------------+---------------+---------------------------------+-----------------------------------+-------------------------------------
 public        | city        | insert_insert | conflict_trigger_returned_tuple | {"city_sid":1,"name":"Newman"}    | {"city_sid":1,"name":"Parabadoo"}
 public        | city        | insert_insert | conflict_trigger_returned_tuple | {"city_sid":3,"name":"Tom Price"} | {"city_sid":2,"name":"Tom Price"}
 public        | city        | update_update | last_update_wins_keep_local     | {"city_sid":10,"name":"Balingup"} | {"city_sid":10,"name":"Dwellingup"}
(3 rows)

SELECT * FROM bdr_log;
            nodeid             | nodeseq |    log_info1    |    log_info2    
-------------------------------+---------+-----------------+-----------------
 (6343025451829079416,1,16385) |       1 | (1,Newman)      | (1,Parabadoo)
 (6343025451829079416,1,16385) |       2 | (3,"Tom Price") | (2,"Tom Price")
(2 rows)

SELECT * FROM city WHERE city_sid IN (10);
 city_sid |   name   
----------+----------
       10 | Balingup
(1 row)

\c postgres
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

SELECT object_schema, object_name, conflict_type, conflict_resolution, local_tuple, remote_tuple FROM bdr.bdr_conflict_history;
 object_schema | object_name | conflict_type |       conflict_resolution       |            local_tuple            |           remote_tuple            
---------------+-------------+---------------+---------------------------------+-----------------------------------+-----------------------------------
 public        | city        | insert_insert | conflict_trigger_returned_tuple | {"city_sid":1,"name":"Parabadoo"} | {"city_sid":1,"name":"Newman"}
 public        | city        | insert_insert | conflict_trigger_returned_tuple | {"city_sid":2,"name":"Tom Price"} | {"city_sid":3,"name":"Tom Price"}
(2 rows)

SELECT * FROM bdr_log;
            nodeid             | nodeseq |    log_info1    |    log_info2    
-------------------------------+---------+-----------------+-----------------
 (6343025451829079416,1,13104) |       1 | (1,Parabadoo)   | (1,Newman)
 (6343025451829079416,1,13104) |       2 | (2,"Tom Price") | (3,"Tom Price")
(2 rows)

SELECT * FROM city WHERE city_sid IN (10);
 city_sid |   name   
----------+----------
       10 | Balingup
(1 row)

-- No point testing for broken replication here, it can't break anything.
---------------------------------------------------
-- Update/Update conflict on PRIMARY KEY change
---------------------------------------------------
INSERT INTO city(city_sid, name) VALUES (4, 'Exmouth'), (5, 'Coral Bay');
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

UPDATE city SET city_sid = 6 WHERE city_sid = 4;
\c regression
UPDATE city SET city_sid = 6 WHERE city_sid = 5;
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

SELECT object_schema, object_name, conflict_type, conflict_resolution, local_tuple, remote_tuple FROM bdr.bdr_conflict_history;
 object_schema | object_name | conflict_type |       conflict_resolution       |            local_tuple            |            remote_tuple             
---------------+-------------+---------------+---------------------------------+-----------------------------------+-------------------------------------
 public        | city        | insert_insert | conflict_trigger_returned_tuple | {"city_sid":1,"name":"Newman"}    | {"city_sid":1,"name":"Parabadoo"}
 public        | city        | insert_insert | conflict_trigger_returned_tuple | {"city_sid":3,"name":"Tom Price"} | {"city_sid":2,"name":"Tom Price"}
 public        | city        | update_update | last_update_wins_keep_local     | {"city_sid":10,"name":"Balingup"} | {"city_sid":10,"name":"Dwellingup"}
(3 rows)

SELECT * FROM bdr_log;
            nodeid             | nodeseq |    log_info1    |    log_info2    
-------------------------------+---------+-----------------+-----------------
 (6343025451829079416,1,16385) |       1 | (1,Newman)      | (1,Parabadoo)
 (6343025451829079416,1,16385) |       2 | (3,"Tom Price") | (2,"Tom Price")
(2 rows)

SELECT * FROM city WHERE city_sid IN (4,5,6);
 city_sid |   name    
----------+-----------
        4 | Exmouth
        6 | Coral Bay
(2 rows)

\c postgres
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

SELECT object_schema, object_name, conflict_type, conflict_resolution, local_tuple, remote_tuple FROM bdr.bdr_conflict_history;
 object_schema | object_name | conflict_type |       conflict_resolution       |            local_tuple            |           remote_tuple            
---------------+-------------+---------------+---------------------------------+-----------------------------------+-----------------------------------
 public        | city        | insert_insert | conflict_trigger_returned_tuple | {"city_sid":1,"name":"Parabadoo"} | {"city_sid":1,"name":"Newman"}
 public        | city        | insert_insert | conflict_trigger_returned_tuple | {"city_sid":2,"name":"Tom Price"} | {"city_sid":3,"name":"Tom Price"}
(2 rows)

SELECT * FROM bdr_log;
            nodeid             | nodeseq |    log_info1    |    log_info2    
-------------------------------+---------+-----------------+-----------------
 (6343025451829079416,1,13104) |       1 | (1,Parabadoo)   | (1,Newman)
 (6343025451829079416,1,13104) |       2 | (2,"Tom Price") | (3,"Tom Price")
(2 rows)

SELECT * FROM city WHERE city_sid IN (4,5,6);
 city_sid |   name    
----------+-----------
        5 | Coral Bay
        6 | Exmouth
(2 rows)

-- Replication broke, oops!
--
-- The logs will report something like:
--
-- ERROR:  duplicate key value violates unique constraint "city_pk"
-- DETAIL:  Key (city_sid)=(6) already exists.
-- CONTEXT:  apply UPDATE from remote relation public.city in commit 0/1B03740, xid 2052 commited at 2016-10-18 06:45:24.693261+00 (action #2) from node (6342692214835298407,1,13104)
--
-- on one or both nodes. Confirm by taking DDL lock:
BEGIN;
SET LOCAL statement_timeout = '10s';
CREATE TABLE sydney(dummy integer);
psql:sql/conflict_cases.sql:133: ERROR:  canceling statement due to statement timeout
ROLLBACK;
-- We can fix this without discarding transactions from the queue by resolving
-- the conflict on one or both sides to allow replication to complete. Simple
-- pg_regress tests can't do things like look at the logs so assume we conflict
-- on both sides.
DELETE FROM city WHERE city_sid = 6;
\c regression
DELETE FROM city WHERE city_sid = 6;
\c postgres
-- When we get the DDL lock we know we've recovered
BEGIN;
SET LOCAL statement_timeout = '10s';
CREATE TABLE sydney(dummy integer);
ROLLBACK;
-- FIXME!
---------------------------------------------------
-- Update/Update conflict on secondary unique index
---------------------------------------------------
-- But what about conflicting UPDATEs that cause violation of a secondary
-- unique index?
UPDATE city SET name = 'Kalgoorlie' WHERE city_sid = 1;
\c regression
UPDATE city SET name = 'Kalgoorlie' WHERE city_sid = 3;
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

SELECT object_schema, object_name, conflict_type, conflict_resolution, local_tuple, remote_tuple FROM bdr.bdr_conflict_history;
 object_schema | object_name | conflict_type |       conflict_resolution       |            local_tuple            |            remote_tuple             
---------------+-------------+---------------+---------------------------------+-----------------------------------+-------------------------------------
 public        | city        | insert_insert | conflict_trigger_returned_tuple | {"city_sid":1,"name":"Newman"}    | {"city_sid":1,"name":"Parabadoo"}
 public        | city        | insert_insert | conflict_trigger_returned_tuple | {"city_sid":3,"name":"Tom Price"} | {"city_sid":2,"name":"Tom Price"}
 public        | city        | update_update | last_update_wins_keep_local     | {"city_sid":10,"name":"Balingup"} | {"city_sid":10,"name":"Dwellingup"}
(3 rows)

SELECT * FROM bdr_log;
            nodeid             | nodeseq |    log_info1    |    log_info2    
-------------------------------+---------+-----------------+-----------------
 (6343025451829079416,1,16385) |       1 | (1,Newman)      | (1,Parabadoo)
 (6343025451829079416,1,16385) |       2 | (3,"Tom Price") | (2,"Tom Price")
(2 rows)

SELECT * FROM city WHERE city_sid IN (1,3);
 city_sid |    name    
----------+------------
        1 | Newman
        3 | Kalgoorlie
(2 rows)

\c postgres
SELECT pg_xlog_wait_remote_apply(pg_current_xlog_location(), 0);
 pg_xlog_wait_remote_apply 
---------------------------
 
(1 row)

SELECT object_schema, object_name, conflict_type, conflict_resolution, local_tuple, remote_tuple FROM bdr.bdr_conflict_history;
 object_schema | object_name | conflict_type |       conflict_resolution       |            local_tuple            |            remote_tuple            
---------------+-------------+---------------+---------------------------------+-----------------------------------+------------------------------------
 public        | city        | insert_insert | conflict_trigger_returned_tuple | {"city_sid":1,"name":"Parabadoo"} | {"city_sid":1,"name":"Newman"}
 public        | city        | insert_insert | conflict_trigger_returned_tuple | {"city_sid":2,"name":"Tom Price"} | {"city_sid":3,"name":"Tom Price"}
 public        | city        | update_delete | skip_change                     |                                   | {"city_sid":3,"name":"Kalgoorlie"}
(3 rows)

SELECT * FROM city WHERE city_sid IN (1,3);
 city_sid |    name    
----------+------------
        1 | Kalgoorlie
(1 row)

SELECT * FROM bdr_log;
            nodeid             | nodeseq |    log_info1    |    log_info2    
-------------------------------+---------+-----------------+-----------------
 (6343025451829079416,1,13104) |       1 | (1,Parabadoo)   | (1,Newman)
 (6343025451829079416,1,13104) |       2 | (2,"Tom Price") | (3,"Tom Price")
(2 rows)

-- ... that seemed to work, after all, pg_xlog_wait_remote_apply returned. But
-- it only returned because there are no walsenders anymore, we'lll be in a crash
-- cycle on one or both nodes and nothing will be replicating.
--
-- Lets try to take the DDL lock, we'll get stuck here.
BEGIN;
SET LOCAL statement_timeout = '10s';
CREATE TABLE sydney(dummy integer);
psql:sql/conflict_cases.sql:179: ERROR:  canceling statement due to statement timeout
ROLLBACK;
-- Output on one or both nodes will be something like:
--
-- ERROR:  duplicate key value violates unique constraint "city_un"
-- DETAIL:  Key (name)=(Kalgoorlie) already exists.
-- CONTEXT:  apply UPDATE from remote relation public.city in commit 0/1B08AA8, xid 2076 commited at 2016-10-18 06:54:14.36732+00 (action #2) from node (6342694436480988016,1 ,16385)
-- To fix it, same deal as before, remove a conflicting row.
DELETE FROM city WHERE name = 'Kalgoorlie';
\c regression
DELETE FROM city WHERE name = 'Kalgoorlie';
\c postgres
BEGIN;
SET LOCAL statement_timeout = '10s';
CREATE TABLE sydney(dummy integer);
ROLLBACK;
-- FIXME!
---------------------------------------------------
-- Two unique violations update/update conflict
---------------------------------------------------
-- TODO
---------------------------------------------------
-- Update/Update conflict on secondary unique expression index
---------------------------------------------------
-- TODO
---------------------------------------------------
-- Update/Update conflict on secondary partial unique index
---------------------------------------------------
-- TODO
---------------------------------------------------
-- Insert/Update conflicts
---------------------------------------------------
-- TODO
--
-- Note that insert/update vs update/delete is ambiguous
-- (might need 3 nodes)
---------------------------------------------------
-- Update/Delete conflicts
---------------------------------------------------
-- TODO
--
-- Note that insert/update vs update/delete is ambiguous
-- (might need 3 nodes)
---------------------------------------------------
-- Delete/Delete "conflicts"
---------------------------------------------------
-- TODO
---------------------------------------------------
-- Insert/Delete conflicts
---------------------------------------------------
-- TODO
-- This probably needs 3 nodes though...
-- *** Ending conflict_cases.sql run ***
-- Now with replica identity set to a non-primary-key unique index...
--ALTER TABLE public.city REPLICA IDENTITY USING INDEX city_un;
-- TODO
-- Tidy up
ALTER SYSTEM
  RESET bdr.default_apply_delay;
SELECT pg_reload_conf();
 pg_reload_conf 
----------------
 t
(1 row)

