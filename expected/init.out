SELECT * FROM bdr_regress_variables()
\gset
\set VERBOSITY terse
\c :node1_dsn
CREATE EXTENSION bdr CASCADE;
NOTICE:  installing required extension "pglogical"
SELECT E'\'' || current_database() || E'\'' AS node1_db
\gset
\c :node2_dsn
CREATE EXTENSION bdr CASCADE;
NOTICE:  installing required extension "pglogical"
SELECT E'\'' || current_database() || E'\'' AS node2_db
\gset
\c :node1_dsn
-- Only used in tests
CREATE FUNCTION bdr_submit_comment(message text)
RETURNS text LANGUAGE c STRICT AS 'bdr','bdr_submit_comment';
SELECT node_name, node_local_state, nodegroup_name, pgl_interface_name FROM bdr.node_group_member_info(NULL) ORDER BY 1;
 node_name | node_local_state | nodegroup_name | pgl_interface_name 
-----------+------------------+----------------+--------------------
(0 rows)

SELECT 1
FROM bdr.create_node(node_name := 'node1', local_dsn := :'node1_dsn' || ' user=super');
NOTICE:  creating new pglogical node
 ?column? 
----------
        1
(1 row)

SELECT node_name, node_local_state, nodegroup_name, pgl_interface_name FROM bdr.node_group_member_info(NULL) ORDER BY 1;
 node_name | node_local_state | nodegroup_name | pgl_interface_name 
-----------+------------------+----------------+--------------------
 node1     |                1 |                | node1
(1 row)

SELECT 1
FROM bdr.create_node_group('bdrgroup');
 ?column? 
----------
        1
(1 row)

-- Wait for the creating node to go fully active
DO LANGUAGE plpgsql $$
BEGIN
  WHILE NOT EXISTS (SELECT 1 FROM bdr.state_journal_details WHERE state_name = 'ACTIVE')
  LOOP
    PERFORM pg_sleep(0.5);
  END LOOP;
END;
$$;
SELECT node_name, node_local_state, nodegroup_name, pgl_interface_name FROM bdr.node_group_member_info(NULL) ORDER BY 1;
 node_name | node_local_state | nodegroup_name | pgl_interface_name 
-----------+------------------+----------------+--------------------
 node1     |                4 | bdrgroup       | node1
(1 row)

SELECT node_name, node_local_state, nodegroup_name, pgl_interface_name FROM bdr.node_group_member_info((SELECT node_group_id FROM bdr.node_group)) ORDER BY 1;
 node_name | node_local_state | nodegroup_name | pgl_interface_name 
-----------+------------------+----------------+--------------------
 node1     |                4 | bdrgroup       | node1
(1 row)

\c :node2_dsn
SELECT node_name, node_local_state, nodegroup_name, pgl_interface_name FROM bdr.node_group_member_info(NULL) ORDER BY 1;
 node_name | node_local_state | nodegroup_name | pgl_interface_name 
-----------+------------------+----------------+--------------------
(0 rows)

SELECT 1
FROM bdr.create_node(node_name := 'node2', local_dsn := :'node2_dsn' || ' user=super');
NOTICE:  creating new pglogical node
 ?column? 
----------
        1
(1 row)

-- TODO: https://redmine.2ndquadrant.com/issues/1057
SELECT pg_sleep(0.5);
 pg_sleep 
----------
 
(1 row)

SELECT 1
FROM bdr.join_node_group(:'node1_dsn', 'nosuch-nodegroup');
ERROR:  remote node is member of nodegroup bdrgroup but we asked to join nodegroup nosuch-nodegroup
-- TODO: https://redmine.2ndquadrant.com/issues/1057
SELECT pg_sleep(0.5);
 pg_sleep 
----------
 
(1 row)

SELECT node_name, node_local_state, nodegroup_name, pgl_interface_name FROM bdr.node_group_member_info((SELECT node_group_id FROM bdr.node_group)) ORDER BY 1;
 node_name | node_local_state | nodegroup_name | pgl_interface_name 
-----------+------------------+----------------+--------------------
 node2     |                1 |                | node2
(1 row)

SELECT 1 FROM bdr.join_node_group(:'node1_dsn', pause_in_standby := true);
NOTICE:  node join started
 ?column? 
----------
        1
(1 row)

SELECT node_name, node_local_state, nodegroup_name, pgl_interface_name FROM bdr.node_group_member_info((SELECT node_group_id FROM bdr.node_group)) ORDER BY 1;
 node_name | node_local_state | nodegroup_name | pgl_interface_name 
-----------+------------------+----------------+--------------------
 node1     |                4 | bdrgroup       | node1
 node2     |                2 | bdrgroup       | node2
(2 rows)

\c :node1_dsn
-- A dummy transaction will help make sure we make prompt progress.
SELECT 1 FROM txid_current();
 ?column? 
----------
        1
(1 row)

-- Forcing a checkpoint will force out replication origins and make us
-- advance more promptly too.
CHECKPOINT;
\c :node2_dsn
-- Wait for the joining node to reach standby state
SELECT bdr.wait_for_join_completion();
 wait_for_join_completion 
--------------------------
 STANDBY
(1 row)

SELECT goal_state_name FROM bdr.state_journal_details ORDER BY state_counter DESC LIMIT 1;
 goal_state_name 
-----------------
 STANDBY
(1 row)

-- Wait for the joining node to reach standby
SELECT bdr.wait_for_join_completion();
 wait_for_join_completion 
--------------------------
 STANDBY
(1 row)

SELECT slot_name, plugin, slot_type, database, temporary
FROM pg_replication_slots ORDER BY slot_name;
             slot_name             |      plugin      | slot_type |  database  | temporary 
-----------------------------------+------------------+-----------+------------+-----------
 bdr_postgres_bdrgroup_node1_node2 | pglogical_output | logical   | regression | f
(1 row)

-- TODO: replicate some minimal test data here
-- TODO: Make standby read-only RM#859
-- Promote to active
SELECT bdr.promote_node();
NOTICE:  node promotion started in the background
 promote_node 
--------------
 
(1 row)

SELECT goal_state_name FROM bdr.state_journal_details ORDER BY state_counter DESC LIMIT 1;
 goal_state_name 
-----------------
 ACTIVE
(1 row)

-- Wait for the joining node to go fully active
SELECT bdr.wait_for_join_completion();
 wait_for_join_completion 
--------------------------
 ACTIVE
(1 row)

SELECT slot_name, plugin, slot_type, database, temporary
FROM pg_replication_slots ORDER BY slot_name;
              slot_name              |      plugin      | slot_type |  database  | temporary 
-------------------------------------+------------------+-----------+------------+-----------
 bdr_postgres_bdrgroup_node1_node2   | pglogical_output | logical   | regression | f
 bdr_regression_bdrgroup_node2_node1 | pglogical_output | logical   | postgres   | f
(2 rows)

\c :node1_dsn
-- Wait for the join target to start replaying from the joining node
-- at the end of BDR setup.
DO LANGUAGE plpgsql $$
BEGIN
  WHILE NOT EXISTS (SELECT 1 FROM pglogical.show_subscription_status() WHERE status = 'replicating')
  LOOP
    PERFORM pg_sleep(0.5);
  END LOOP;
END;
$$;
SELECT subscription_name, status, provider_node, slot_name, replication_sets
FROM pglogical.show_subscription_status();
 subscription_name |   status    | provider_node |              slot_name              | replication_sets 
-------------------+-------------+---------------+-------------------------------------+------------------
 bdrgroup_node2    | replicating | node2         | bdr_regression_bdrgroup_node2_node1 | {bdrgroup}
(1 row)

SET client_min_messages = notice;
-- Wait for it to start up
-- We already created the slots so all we have to do here is wait for
-- the slots to be in sync once we do some WAL-logged work on the
-- upstreams.
CREATE TABLE throwaway AS SELECT 1;
\c :node2_dsn
CREATE TABLE throwaway AS SELECT 1;
\c :node1_dsn
SELECT pglogical.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

SELECT application_name, sync_state
FROM pg_stat_replication
ORDER BY application_name;
 application_name | sync_state 
------------------+------------
 bdrgroup_node1   | async
 bdrgroup_node2   | async
(2 rows)

SELECT slot_name, plugin, slot_type, database, temporary
FROM pg_replication_slots ORDER BY slot_name;
              slot_name              |      plugin      | slot_type |  database  | temporary 
-------------------------------------+------------------+-----------+------------+-----------
 bdr_postgres_bdrgroup_node1_node2   | pglogical_output | logical   | regression | f
 bdr_regression_bdrgroup_node2_node1 | pglogical_output | logical   | postgres   | f
(2 rows)

SELECT
    backend_type,
    regexp_replace(application_name, '[[:digit:]]', 'n', 'g') AS appname
FROM pg_stat_activity
WHERE application_name LIKE 'pglogical%'
ORDER BY appname;
   backend_type    |               appname               
-------------------+-------------------------------------
 background worker | pglogical manager nnnnn
 background worker | pglogical manager nnnnn
 background worker | pglogical receiver nnnnn:nnnnnnnnnn
 background worker | pglogical receiver nnnnn:nnnnnnnnnn
 background worker | pglogical supervisor
(5 rows)

\c :node2_dsn
SELECT subscription_name, status, provider_node, slot_name, replication_sets
FROM pglogical.show_subscription_status();
 subscription_name |   status    | provider_node |             slot_name             | replication_sets 
-------------------+-------------+---------------+-----------------------------------+------------------
 bdrgroup_node1    | replicating | node1         | bdr_postgres_bdrgroup_node1_node2 | {bdrgroup}
(1 row)

\c :node1_dsn
SELECT
    state_counter, state, state_name, peer_id, peer_name,
    regexp_replace(
	regexp_replace(extra_data, '[[:xdigit:]]{1,8}/[[:xdigit:]]{8}', 'X/XXXXXXXX'),
	 '[[:digit:]]', 'n', 'g') AS extra_data_masked
FROM bdr.state_journal_details;
 state_counter | state | state_name | peer_id | peer_name | extra_data_masked 
---------------+-------+------------+---------+-----------+-------------------
             1 |     1 | CREATED    |       0 |           | 
             2 |  5000 | ACTIVE     |       0 |           | 
(2 rows)

SELECT pn.node_name, jcp.min_slot_lsn IS NOT NULL, jcp.passed_min_slot_lsn
FROM bdr.join_catchup_minimum jcp JOIN pglogical.node pn ON jcp.node_id = pn.node_id
ORDER BY pn.node_name;
 node_name | ?column? | passed_min_slot_lsn 
-----------+----------+---------------------
(0 rows)

\c :node2_dsn
SELECT
    state_counter, state, state_name, peer_id, peer_name,
    regexp_replace(
	regexp_replace(extra_data, '[[:xdigit:]]{1,8}/[[:xdigit:]]{8}', 'X/XXXXXXXX'),
	 '[[:digit:]]', 'n', 'g') AS extra_data_masked
FROM bdr.state_journal_details;
 state_counter | state |          state_name          |  peer_id   | peer_name |         extra_data_masked          
---------------+-------+------------------------------+------------+-----------+------------------------------------
             1 |     1 | CREATED                      |          0 |           | 
             2 |  1000 | JOIN_START                   | 1148549230 | node1     | node group name: bdrgroup
             3 |  1010 | JOIN_WAIT_CONFIRM            | 1148549230 | node1     | global consensus message handle: n
             4 |  1020 | JOIN_COPY_REMOTE_NODES       | 1148549230 | node1     | 
             5 |  1025 | JOIN_CREATE_TARGET_SLOT      | 1148549230 | node1     | 
             6 |  1040 | JOIN_SUBSCRIBE_JOIN_TARGET   | 1148549230 | node1     | 
             7 |  1050 | JOIN_WAIT_SUBSCRIBE_COMPLETE | 1148549230 | node1     | 
             8 |  1080 | JOIN_COPY_REPSET_MEMBERSHIPS | 1148549230 | node1     | 
             9 |  1055 | JOIN_CREATE_SUBSCRIPTIONS    | 1148549230 | node1     | 
            10 |  1060 | JOIN_GET_CATCHUP_LSN         | 1148549230 | node1     | 
            11 |  1070 | JOIN_WAIT_CATCHUP            | 1148549230 | node1     | minimum catchup lsn: X/XXXXXXXX
            12 |  1090 | JOIN_CREATE_PEER_SLOTS       | 1148549230 | node1     | 
            13 |  1100 | JOIN_WAIT_STANDBY_REPLAY     | 1148549230 | node1     | 
            14 |  1110 | SEND_STANDBY_READY           | 1148549230 | node1     | 
            15 |  2000 | STANDBY                      | 1148549230 | node1     | 
            16 |  2005 | PROMOTING                    | 1148549230 | node1     | 
            17 |  2010 | REQUEST_GLOBAL_SEQ_ID        | 1148549230 | node1     | 
            18 |  2020 | WAIT_GLOBAL_SEQ_ID           | 1148549230 | node1     | global consensus message handle: n
            19 |  2030 | CREATE_LOCAL_SLOTS           | 1148549230 | node1     | 
            20 |  2040 | SEND_ACTIVE_ANNOUNCE         | 1148549230 | node1     | 
            21 |  5000 | ACTIVE                       |          0 |           | 
(21 rows)

SELECT pn.node_name, jcp.min_slot_lsn IS NOT NULL, jcp.passed_min_slot_lsn
FROM bdr.join_catchup_minimum jcp JOIN pglogical.node pn ON jcp.node_id = pn.node_id
ORDER BY pn.node_name;
 node_name | ?column? | passed_min_slot_lsn 
-----------+----------+---------------------
(0 rows)

