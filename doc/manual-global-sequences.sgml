<chapter id="global-sequences" xreflabel="Global sequences">
 <title>Global Sequences</title>
 <indexterm>
  <primary>Global Sequence</primary>
  <secondary>Distributed sequence</secondary>
 </indexterm>

 <para>
  &bdr; global sequences provide an easy, fast and reliable way for
  applications to use the database to generate unique synthetic keys in an
  asynchronous distributed system.
 </para>

 <sect1 id="global-sequences-purpose" xreflabel="Purpose of global sequences">
  <title>Purpose of global sequences</title>

  <para>
   Many applications require unique values be assigned to database entries. Some
   applications use <application>GUID</application>s generated by external
   programs, some use database-supplied values. This is important with
   optimistic conflict resolution schemes (like that in &bdr;) because
   uniqueness violations are "divergent errors" and are not easily resolvable.
  </para>

  <para>
   The SQL standard requires <literal>SEQUENCE</literal> objects which generate
   unique values.  These can then be used to supply default values using
   <literal>DEFAULT nextval('mysequence')</literal>, as with PostgreSQL's
   <literal>SERIAL</literal> pseudo-type. PostgreSQL doesn't provide
   any facilities to synchronise or replicate sequences, so they're purely
   node-local.
  </para>

  <para>
   A typical approach for sharded or multi-node applications is to use
   split-step or partitioned sequences, where all nodes increment the sequence
   by the same fixed value and each node has a fixed offset within the sequence.
   So node 1 generates IDs 1, 101, 201, 301, ...; node 2 generates IDs 2, 102,
   202, 302, ...; etc. This is easily done with PostgreSQL's existing sequences,
   but becomes a major problem if you don't allow enough room for growth - in
   the above, if you have 101 nodes you're in serious trouble. It's also
   awkward, requiring node-specific DDL and setup. See <xref
   linkend="global-sequences-alternatives">.
  </para>

  <para>
   To help avoid <xref linkend="conflicts"> on concurrent inserts &bdr; provides
   global sequences. A global sequence looks to applications just like a normal
   PostgreSQL sequence and values are allocated from it using
   <function>nextval</function> like normal. Unlike a normal PostgreSQL sequence,
   which is not synchronized between nodes in any way, global sequences
   are guaranteed to produce unique values <emphasis>across all members
   of a bdr node group</emphasis>.
  </para>

 </sect1>

 <sect1 id="global-sequences-when" xreflabel="When to use global sequences">
  <title>When to use global sequences</title>

  <para>
   Using distributed sequences allows you to avoid the problems with inserts
   conflicts. If you define a <literal>PRIMARY KEY</literal> or
   <literal>UNIQUE</literal> column with a <literal>DEFAULT
   nextval(...)</literal> expression that refers to a global sequence shared
   across all nodes in a BDR group it is not possible for any node to ever get
   the same value as any other node. When BDR synchronizes inserts between the
   nodes, they can never conflict.
  </para>

  <para>
   There is no need to use a distributed sequence if:
   <itemizedlist>
    <listitem>
     <para>
      You are ensuring global uniqueness using another method such as:
      <itemizedlist>
       <listitem><simpara>Local sequences with an offset and increment;</simpara></listitem>
       <listitem><simpara>UUIDs;</simpara></listitem>
       <listitem><simpara>An externally co-ordinated natural key</simpara></listitem>
      </itemizedlist>
     </para>
    </listitem>
    <listitem>
     <para>
      You are using the data in a <literal>TEMPORARY</literal> or
      <literal>UNLOGGED</literal> table, as these are never visible outside the
      current node.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Global sequences are not suitable for applications that require an
   <literal>INCREMENT</literal> other than 1. See
   <xref linkend="global-sequence-limitations">.
  </para>

  <para>
   Sequence values are handed out in chunks, so if three different nodes all
   call <function>nextval</function> at the same time they might get values 50,
   150 and 250. Thus, at time 't' <function>nextval</function> on one node may
   return a value higher than a <function>nextval</function> call at time 't+1'
   on another node. Within a single node the usual rules for
   <function>nextval</function> still apply. This means that applications that
   require generated IDs to strictly increase with time will not work well with
   global sequences - however, such applications will also have problems with
   all other approaches to generating keys in distributed systems (see <xref
   linkend="global-sequences-alternatives">).
  </para>

 </sect1>

 <sect1 id="global-sequence-usage" xreflabel="Using global sequences">
  <title>Using global sequences</title>

  <para>
   Basic usage of global sequences is trivial: In a &bdr; node,
   when creating a sequence, append <literal>USING bdr;</literal>
   to your sequence creation statement:
   <programlisting>
   CREATE SEQUENCE test_seq USING bdr;
   </programlisting>
  </para>

  <para>
   Once you've created a global sequence you may use it with nextval like
   any other sequence.
  </para>

  <para>
   Most PostgreSQL applications don't use <literal>CREATE SEQUENCE</literal>
   directly; instead, they use the <literal>SERIAL</literal> pseudo-type.
   To accomodate this, &bdr; provides the <xref linkend="guc-default-sequenceam">
   parameter. When set to <literal>bdr</literal>, all sequences will be
   automatically created as global sequences unless explicitly overridden
   by a <literal>USING</literal> option. So every <literal>SERIAL</literal>
   or <literal>BIGSERIAL</literal> will automatically be a global sequence.
   e.g.:
   <programlisting>
    BEGIN;

    SET LOCAL default_sequenceam = 'bdr';

    CREATE TABLE gstest (
      id serial primary key,
      parrot text
    );

    COMMIT;
   </programlisting>
   will create a global sequence named <literal>gstest_id_seq</literal> and
   set the <literal>DEFAULT</literal> of <literal>gstest.id</literal> to
   <literal>nextval('gstest_id_seq')</literal>.
  </para>

 </sect1>

 <sect1 id="global-sequence-listing" xreflabel="Listing global sequences">
  <title>Listing global sequences</title>

  <para>
   Global sequences may be listed with:
   <programlisting>
   SELECT *
   FROM pg_class
   INNER JOIN pg_seqam ON (pg_class.relam = pg_seqam.oid)
   WHERE pg_seqam.seqamname = 'bdr' AND relkind = 'S';
   </programlisting>
  </para>

  <para>
   When using the <application>psql</> client provided by BDR PostgreSQL,
   the sequence access method is also visible in the output of the
   <command>\ds</> command.
  </para>

 </sect1>

 <sect1 id="global-sequence-limitations" xreflabel="Global Sequence Limitations">
  <title>Global sequence limitations</title>

  <para>
   A few limitations and caveats apply to global sequences at time of writing:
  </para>

  <para>
   Only an <literal>INCREMENT</literal> of 1 (the default) is supported. Client
   applications that expect a different increment must be configured to handle
   increment 1. An extended variant of <literal>nextval</literal> that takes
   the number of values to obtain as an argument and returns a set of values is
   planned as an extension to aid in porting.
  </para>

  <para>
   <literal>MINVALUE</literal> and <literal>MAXVALUE</literal> are locked at
   their defaults and may not be changed.
  </para>

  <para>
   The <literal>CACHE</literal> directive is not supported.
  </para>

  <para>
   <function>nextval</function> calls may fail with an <literal>ERROR</literal>
   on a global sequence, either when newly created or when there are connectivity
   problems between nodes. This is not possible for normal PostgreSQL sequences.
   See <xref linkend="global-sequence-voting"> for details. This limitation
   may be lifted in a later &bdr; release by allowing global sequence allocations
   to wait until ready instead of producing an error.
  </para>

 </sect1>

 <sect1 id="global-sequence-voting" xreflabel="Global Sequence Voting">
  <title>Global sequence voting</title>

  <para>
   Global sequences allocate values in chunks. Each chunk allocation
   is done by voting between the nodes to make sure that no chunk
   is ever allocated to more than one node. For this to work, enough
   nodes must be reachable to reach a binding vote. &bdr; requires
   that half the nodes, plus one, be able to communicate in order
   to vote successfully.
  </para>

  <para>
   If more than half the nodes are down or are unreachable from a given node
   then global sequence voting cannot achieve a quorum, so new chunks will not
   be allocated in global sequences on that node. Inability to acquire new
   global sequence chunks will eventually cause <function>nextval</function>
   calls on that node to fail with:
   <programlisting>
    ERROR: could not find free sequence value for global sequence
   </programlisting>
   until connectivity is restored and the next round of voting has completed.
  </para>

  <para>
   It is possible nodes that are up but isolated to be unable to get new
   global sequence chunks while the rest of the &bdr; group continues to
   function normally. If no individual connected group of nodes contains more
   than half the total node count then no node will be able to allocate global
   sequence chunks.
  </para>

  <para>
   Global sequences are not immediately ready for use. Attemting to create
   then immediately use a global sequence, before the first round of voting,
   will result in an error like:
   <programlisting>
    ERROR: global sequence public.myseq is not initialized yet
   </programlisting>
   Simply insert a delay before using the sequence.
  </para>

  <para>
   See also <xref linkend="global-sequence-limitations">.
  </para>

 </sect1>

 <sect1 id="global-sequences-alternatives">
  <title>Traditional approaches to sequences in distributed DBs</title>

  <para>
   Global sequences provide an application-transparent alternative to
   using offset-step sequences or
   <acronym>UUID</acronym>/<acronym>GUID</acronym> keys.
  </para>

  <para>
   In offset-step sequences a normal PostgreSQL sequence is used on each node.
   Each sequence increments by the same amount and starts at differing offsets.
   For example with step 1000 node1's sequence generates 1001, 2001, 3001, and
   so on, node 2's generates 1002, 2002, 3002, etc. This scheme works well
   even if the nodes cannot communicate for extended periods, but requires
   that the designer specify a maximum number of nodes when establishing the
   schema and requires per-node configuration. Mistakes can easily lead to
   overlapping sequences.
  </para>

  <para>
   <acronym>UUID</acronym> keys instead eschew sequences entirely and
   use 128-bit universal unique identifiers. These are large random
   or pseudorandom values that are large enough that it's nearly
   impossible for the same value to be generated twice. There is
   no need for nodes to have continuous communication when using
   <acronym>UUID</acronym> keys. In the incredibly unlikely event
   of a collision, manual operator intervention is required to repair
   the database before it can continue to replicate. The main downside
   of <acronym>UUID</acronym> keys is that they're space- and
   network-inefficient, consuming lots of space not only as a primary key, but
   also where referenced in foreign keys and when transmitted on the wire.
   Additionally, not all applications cope well with
   <application>UUID</application> keys.
  </para>

  <para>
   &bdr; users may use either of these approaches. It is not necessary
   to use global sequences, and both the above key generation approaches
   continue to work normally. However, global sequences offer a
   zero-configuration, easy to deploy alternative that doesn't require
   application changes.
  </para>

 </sect1>

</chapter>
