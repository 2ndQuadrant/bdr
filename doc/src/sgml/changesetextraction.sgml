<!-- doc/src/sgml/changesetextraction.sgml -->
 <chapter id="changesetextraction">
  <title>Changeset Extraction</title>
  <indexterm zone="changesetextraction">
   <primary>Changeset Extraction</primary>
  </indexterm>
  <para>
   PostgreSQL provides infrastructure to stream the modifications performed
   via SQL to external consumers which can be used to implement replication
   solutions, perform auditing and similar tasks.
  </para>

  <para>
   <indexterm><primary>Changeset Extraction Slot</primary></indexterm>
   A changeset extraction slot ("logical replication slot") is a persistent
   server-side record of the replay progress of a stream of changes. A stream of
   changes is read from the slot to a receiving client program.
  </para>
  <para>
   The format in which those changes are streamed is determined by the output
   plugin used. While an example plugin is provided, additional plugins can be
   written to extend the choice of available formats without modifying any
   core code.
   Every output plugin has access to each individual new row produced
   by <command>INSERT</command>, and the new row version created
   by <command>UPDATE</command>. Which data is available for rows affected
   by <command>DELETE</command> and for the old row version in
   an <command>UPDATE</command> depends on the relation's
   configured <link linkend="SQL-CREATETABLE-REPLICA-IDENTITY"><literal>REPLICA
   IDENTITY</literal></link>.
  </para>
  <para>
   Changes can be consumed either using one streaming replication protocol
   (see <xref linkend="protocol-replication"> and
   <xref linkend="changesetextraction-walsender">), or by calling functions
   via SQL (see <xref linkend="changesetextraction-sql">). It is also possible
   to write additional methods of consuming the output of a replication slot
   without modifying core code
   (see <xref linkend="changesetextraction-writer">).
  </para>

  <sect1 id="changesetextraction-example">
   <title>Changeset Extraction Example</title>
   <para>
    The following example shows usage of the SQL interface.
   </para>
   <para>
    Before you can use changeset extraction you must edit
    <literal>postgresql.conf</literal> and ensure the following parameters are
    set to at least:
    <programlisting>
wal_level = logical
max_replication_slots = 1
max_wal_senders = 1
    </programlisting>
    and restart PostgreSQL. Then connect to the target database (in the example
    below, <literal>postgres</literal>) as a superuser.
   </para>
   <programlisting>
postgres=# -- max_replication_slots must be nonzero and wal_level must be logical
postgres=# SHOW max_replication_slots;
 max_replication_slots
-----------------------
 1
(1 row)

postgres=# SHOW wal_level;
 wal_level
-----------
 logical
(1 row)

postgres=# -- The decoding plugin you want must be installed. If no rows are returned,
postgres=# -- then cd contrib/test_decoding && make install then re-check.
postgres=#
postgres=# select * from pg_available_extensions WHERE name = 'test_decoding';
     name      | default_version | installed_version |                              comment
---------------+-----------------+-------------------+-------------------------------------------------------------------
 test_decoding | 1.0             | 1.0               | test output plugin for changeset extraction / logical replication
(1 row)

postgres=# SELECT * FROM pg_replication_slots;
 slot_name | plugin | slot_type | datoid | database | active | xmin | catalog_xmin | restart_lsn
-----------+--------+-----------+--------+----------+--------+------+--------------+-------------
(0 rows)

postgres=# -- Create a slot named 'regression_slot' using the output plugin 'test_decoding'
postgres=# SELECT * FROM pg_create_decoding_replication_slot('regression_slot', 'test_decoding');
    slotname     | xlog_position
-----------------+---------------
 regression_slot | 0/16B1970
(1 row)

postgres=# SELECT * FROM pg_replication_slots;
    slot_name    |    plugin     | slot_type | datoid | database | active | xmin | catalog_xmin | restart_lsn
-----------------+---------------+-----------+--------+----------+--------+------+--------------+-------------
 regression_slot | test_decoding | logical   |  12057 | postgres | f      |      |              | 0/169C620
(1 row)

postgres=# -- There are no changes to see yet
postgres=# SELECT * FROM pg_decoding_slot_get_changes('regression_slot', 'now', 'include-xids', '0');
 location | xid | data
----------+-----+------
(0 rows)

postgres=# CREATE TABLE data(id serial primary key, data text);
CREATE TABLE

postgres=# -- DDL isn't replicated, so all you'll see is the transaction
postgres=# SELECT * FROM pg_decoding_slot_get_changes('regression_slot', 'now', 'include-xids', '0');
 location  | xid |  data
-----------+-----+--------
 0/16E1558 | 716 | BEGIN
 0/16EBAC8 | 716 | COMMIT
(2 rows)

postgres=# -- Once changes are read, they're consumed and not emitted
postgres=# -- in a subsequent call:
postgres=# SELECT * FROM pg_decoding_slot_get_changes('regression_slot', 'now', 'include-xids', '0');
 location | xid | data
----------+-----+------
(0 rows)

postgres=# BEGIN;
postgres=# INSERT INTO data(data) VALUES('1');
postgres=# INSERT INTO data(data) VALUES('1');
postgres=# COMMIT;

postgres=# SELECT * FROM pg_decoding_slot_get_changes('regression_slot', 'now', 'include-xids', '0');
 location  | xid |                     data
-----------+-----+-----------------------------------------------
 0/16EBD10 | 718 | BEGIN
 0/16EBE60 | 718 | table "data": INSERT: id[int4]:2 data[text]:1
 0/16EBE60 | 718 | table "data": INSERT: id[int4]:3 data[text]:1
 0/16EBE60 | 718 | COMMIT
(4 rows)

postgres=# INSERT INTO data(data) VALUES('1');

postgres=# -- You can also peek ahead in the change stream without consuming changes
postgres=# SELECT * FROM pg_decoding_slot_peek_changes('regression_slot', 'now', 'include-xids', '0');
 location  | xid |                     data
-----------+-----+-----------------------------------------------
 0/16EBE98 | 719 | BEGIN
 0/16EBF58 | 719 | table "data": INSERT: id[int4]:4 data[text]:1
 0/16EBF58 | 719 | COMMIT
(3 rows)

postgres=# SELECT * FROM pg_decoding_slot_peek_changes('regression_slot', 'now', 'include-xids', '0');
 location  | xid |                     data
-----------+-----+-----------------------------------------------
 0/16EBE98 | 719 | BEGIN
 0/16EBF58 | 719 | table "data": INSERT: id[int4]:4 data[text]:1
 0/16EBF58 | 719 | COMMIT

postgres=# -- Remember to destroy a slot you no longer need to stop it consuming
postgres=# -- server resources:
postgres=# SELECT pg_drop_replication_slot('regression_slot');
 pg_drop_replication_slot
-----------------------

(1 row)
    </programlisting>
   <para>
    The following example shows usage of the walsender interface using
    the <link linkend="app-pgrecvlogical"><command>pg_recvlogical</command></link>
    shell command. It requires the replication configurations to be allowed
    (see <xref linkend="streaming-replication-authentication">)
    and <varname>max_wal_senders</varname> to be set sufficiently high for
    another connection.
   </para>
   <programlisting>
# pg_recvlogical -d testdb --slot test --create
# pg_recvlogical -d testdb --slot test --start -f -
CTRL-Z
# psql -c "INSERT INTO data(data) VALUES('1');"
# fg
BEGIN 721
table "data": INSERT: id[int4]:5 data[text]:1
COMMIT 721
CTRL-C
# pg_recvlogical -d testdb --slot test --drop
   </programlisting>
  </sect1>
  <sect1 id="changesetextraction-explanation">
   <title>Changeset Extraction Concepts</title>
   <sect2>
    <indexterm>
     <primary>Changeset Extraction</primary>
    </indexterm>
    <indexterm>
     <primary>Changeset Generation</primary>
    </indexterm>
    <title>Changeset Extraction</title>
    <para>
     Changeset Extraction is the the process of extracting all persistent
     changes to a database's tables into a coherent, easy to understand format
     which is easy to interpret independent of the way the changes were made.
    </para>
    <para>
     In <productname>PostgreSQL</productname> changeset extraction is
     implemented by decoding the <link linkend="wal">WAL's</link> contents,
     which describe changes on a storage level, into an easier to interpret
     format. That process is called logical decoding.
    </para>
   </sect2>
   <sect2>
    <indexterm>
     <primary>Logical Replication Slot</primary>
    </indexterm>
    <indexterm>
     <primary>Replication Slot</primary>
    </indexterm>
    <title>Replication Slots</title>
    <para>
     In the context of changeset extraction a replication slot represents a
     stream of changes which can be replayed to a client in the order they
     were made on the origin server. Each slot streams a sequence of changes
     from a single database, sending each change exactly once (unless peeking
     forward in the stream).
    </para>
    <note>
     <para>PostgreSQL also has streaming replication slots
     (see <xref linkend="streaming-replication">), but they are used somewhat
     differently there.
     </para>
    </note>
    <para>
     Replication slots have an identifier which is unique across all databases
     in a <productname>PostgreSQL</productname> cluster. Slots persist
     independently of the connection using them and are crash-safe.  They can
     be allocated in primary servers and hot-standby servers (streaming
     replicas or archive-replaying hot standbys), so it's possible to
     replicate changes over physical replication then read a logical change
     stream from a physical replica server.
    </para>
    <para>
     Multiple independent slots may exist for a single database. Each slot has
     its own state, allowing different consumers to receive changes from
     different points in the database change stream. For most applications a
     separate slot is required for each changeset consumer.
    </para>
    <para>
     A changeset extraction slot knows nothing about the state of the
     receiver(s).  It's even possible to have multiple different receivers use
     the same slot at different times; they'll just get the changes following
     on from when the last receiver stopped consuming them. Only one receiver
     may consume changes from a slot at any given time.
    </para>
    <sect3 id="changesetextraction-abandoned-slots">
     <title>Unused/abandoned slots</title>
     <para>
      Changeset extraction slots persist across crashes and know nothing about
      the state of their consumer(s). They will prevent removal of required
      resources even when there is no connection using them. This consumes
      storage because neither required WAL nor required rows from the system
      catalogs can be removed by VACUUM as long as they are required by a
      replication slot, so if a slot is no longer required it should be
      dropped.
     </para>
     <para>
      Slots may be created manually, or using a client like a replication
      tool. Keep this in mind when you retire a client that uses a changeset
      extraction slot, like a logical replica - you may need to give it a
      specific command to remove its changeset extraction slot, or drop the
      slot yourself, even if you did not initially create the slot by hand.
     </para>
    </sect3>
   </sect2>
   <sect2>
    <title>Exported Snapshots</title>
    <para>
     When a new replication slot is created over the walsender interface a
     snapshot is exported
     (see <xref linkend="functions-snapshot-synchronization">) which will show
     exactly the state of the database after which all changes will be
     included in the changestream. This can be used to create a new replica by
     using <link linkend="sql-set-transaction"><literal>SET TRANSACTION
     SNAPSHOT</literal></link> to read the state of the database at the moment
     the slot was created. This transaction can then be used to dump the
     database's state at that point in time which afterwards can be updated
     using the slot's contents without loosing any changes.
    </para>
   </sect2>
  </sect1>
  <sect1 id="changesetextraction-walsender">
   <title>Streaming Replication Protocol Interface</title>
   <para>
    The <literal>CREATE_REPLICATION_SLOT SLOT slotname LOGICAL
    options</literal>, <literal>DROP_REPLICATION_SLOT SLOT slotname</literal>
    and <literal>START_REPLICATION SLOT slotname LOGICAL options</literal>
    commands can be used to create, drop and stream changes from a replication
    slot respectively. These commands are only available over a replication
    connection; the won't work from the SQL
    level. See <xref linkend="protocol-replication">.
   </para>
   <para>
    The <command>pg_recvlogical</command> command
    (see <xref linkend="app-pgrecvlogical">) can be used to control changeset
    extraction over a walsender connection.
   </para>
  </sect1>
  <sect1 id="changesetextraction-sql">
   <title>Changeset Extraction <acronym>SQL</acronym> Interface</title>
   <para>
     See <xref linkend="functions-replication"> for detailed
     documentation on the SQL-level API for interacting with changeset
     extraction.
   </para>
   <para>
    Only replications slots which are consumed over the walsender interface
    support being used for synchronous replication
    (see <xref linkend="synchronous-replication">).
   </para>
  </sect1>
  <sect1 id="changesetextraction-catalogs">
   <title>System catalogs related to changeset extraction</title>
   <para>
    The <xref linkend="catalog-pg-replication-slots"> view and the
    <literal>pg_stat_replication</literal> view
    in <xref linkend="monitoring-stats-views-table"> provide information about
    the current state of replication slots and walsender connections
    respectively. These views apply to both physical and logical replication.
   </para>
  </sect1>
  <sect1 id="changesetextraction-output-plugin">
   <title>Changeset Extraction Output Plugins</title>
   <para>
    An example output plugin can be found in the
    <link linkend="test-decoding">
     <filename>contrib/test_decoding</filename>
    </link>
    subdirectory of the PostgreSQL source tree.
   </para>
   <sect2 id="changesetextraction-output-init">
    <title>Initialization Function</title>
    <indexterm zone="changesetextraction">
     <primary>_PG_output_plugin_init</primary>
    </indexterm>
    <para>
     An output plugin is loaded by dynamically loading a shared library with
     the output plugin's name as the library basename. The normal library
     search path is used to locate the library. To provide the required output
     plugin callbacks and to indicate that the library is actually an output
     plugin it needs to provide a function named
     <function>_PG_output_plugin_init</function>. This function is passed a
     struct that needs to be filled with the callback function pointers for
     individual actions.
     <programlisting>
typedef struct OutputPluginCallbacks
{
    LogicalDecodeStartupCB startup_cb;
    LogicalDecodeBeginCB begin_cb;
    LogicalDecodeChangeCB change_cb;
    LogicalDecodeCommitCB commit_cb;
    LogicalDecodeShutdownCB shutdown_cb;
} OutputPluginCallbacks;
typedef void (*LogicalOutputPluginInit)(struct OutputPluginCallbacks *cb);
     </programlisting>
     The <function>begin_cb</function>, <function>change_cb</function>
     and <function>commit_cb</function> callbacks are required,
     while <function>startup_cb</function>
     and <function>shutdown_cb</function> are optional.
    </para>
   </sect2>

   <sect2 id="changesetextraction-capabilities">
    <title>Capabilities</title>
    <para>
     To decode, format and output changes, output plugins can use most of the
     backend's normal infrastructure, including calling output functions. Read
     only access to relations is permitted as long as only relations are
     accessed that either have been created by initdb in
     the <literal>pg_catalog</literal> schema, or have are marked as user
     provided catalog tables using
     <programlisting>
ALTER TABLE user_catalog_table SET (user_catalog_table = true);
CREATE TABLE another_catalog_table(data text) WITH (user_catalog_table = true);
     </programlisting>
     Any actions leading to XID assignment are prohibited. That, among others,
     includes writing to tables, performing DDL changes and
     calling <literal>txid_current()</literal>.
    </para>
   </sect2>

   <sect2 id="changesetextraction-output-plugin-callbacks">
    <title>Output Plugin Callbacks</title>
    <para>
     An output plugin gets notified about changes that are happening via
     various callbacks it needs to provide.
    </para>
    <para>
     Concurrent transactions are decoded in commit order and only changes
     belonging to a specific transaction are decoded inbetween
     the <literal>begin</literal> and <literal>commit</literal>
     callbacks. Transaction that were rolled back explicitly or implicitly
     will never be
     decoded. Successfull <link linkend="SQL-SAVEPOINT">SAVEPOINTs</link> are
     folded into the transaction containing them in the order they were
     exectuded within that transaction.
    </para>
    <note>
     <para>
      Only transactions that have already safely been flushed to disk will be
      decoded. That can lead to a COMMIT not immediately being decoded in a
      directly following <literal>pg_decoding_slot_get_changes()</literal>
      when <varname>synchronous_commit</varname> is set
      to <literal>off</literal>.
     </para>
    </note>
    <sect3 id="changesetextraction-output-plugin-startup">
     <title>Startup Callback</title>
     <para>
      The optional <function>startup_cb</function> callback is called whenever
      an replication slot is created or asked to stream changes, independent
      of the number of changes that are ready to be output.
      <programlisting>
typedef void (*LogicalDecodeStartupCB) (
    struct LogicalDecodingContext *ctx,
    OutputPluginOptions *options,
    bool is_init
);
      </programlisting>
      The <literal>is_init</literal> paramter will be true when the
      replication slot is being created and false
      otherwise. <parameter>options</parameter> points to a struct of options
      that output plugins can set:
      <programlisting>
typedef struct OutputPluginOptions
{
    OutputPluginOutputType output_type;
} OutputPluginOptions;
      </programlisting>
      <literal>output_type</literal> has to either be set to
      <literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal>
      or <literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal>.
     </para>
     <para>
      The startup callback should validate the options present in
      <literal>ctx-&gt;output_plugin_options</literal>. If the output plugin
      needs to have a state, it can
      use <literal>ctx-&gt;output_plugin_private</literal> to store it.
     </para>
    </sect3>
    <sect3 id="changesetextraction-output-plugin-shutdown">
     <title>Shutdown Callback</title>
     <para>
      The optional <function>shutdown_cb</function> callback is called
      whenever a formerly active replication slot is not used anymore and can
      be used to deallocate resources private to the output plugin. The slot
      isn't necessarily being dropped, streaming is just being stopped.
      <programlisting>
typedef void (*LogicalDecodeShutdownCB) (
    struct LogicalDecodingContext *ctx
);
      </programlisting>
     </para>
   </sect3>
    <sect3 id="changesetextraction-output-plugin-begin">
     <title>Transaction Begin Callback</title>
     <para>
      The required <function>begin_cb</function> callback is called whenever a
      transaction start has been decoded, but only if we know that the
      transaction has committed. Aborted transactions and their contents are
      never decoded.
      <programlisting>
typedef void (*LogicalDecodeBeginCB) (
    struct LogicalDecodingContext *,
    ReorderBufferTXN *txn
);
      </programlisting>
      The <parameter>txn</parameter> parameter contains meta information about
      the transaction, like the timestamp at which it committed and its XID.
     </para>
   </sect3>
    <sect3 id="changesetextraction-output-plugin-commit">
     <title>Transaction End Callback</title>
     <para>
      The required <function>commit_cb</function> callback is called whenever
      a transaction commit has been
      decoded. The <function>change_cb</function> callbacks for all modified
      rows will have been called before this, if there have been any modified
      rows.
      <programlisting>
typedef void (*LogicalDecodeCommitCB) (
    struct LogicalDecodingContext *,
    ReorderBufferTXN *txn
);
      </programlisting>
     </para>
    </sect3>
    <sect3 id="changesetextraction-output-plugin-change">
     <title>Callback called for each individual change in a
     transaction</title>
     <para>
      The required <function>change_cb</function> callback is called for every
      individual row modification inside a transaction, may it be
      an <command>INSERT</command>, <command>UPDATE</command>
      or <command>DELETE</command>. Even if the original command modified
      several rows at once the callback will be called indvidually for each
      row.
      <programlisting>
typedef void (*LogicalDecodeChangeCB) (
    struct LogicalDecodingContext *ctx,
    ReorderBufferTXN *txn,
    Relation relation,
    ReorderBufferChange *change
);
      </programlisting>
      The <parameter>ctx</parameter> and <parameter>txn</parameter> parameters
      have the same contents as for the <function>begin_cb</function>
      and <function>commit_cb</function> callbacks, but additionally the
      relation descriptor <parameter>relation</parameter> for the relation the
      row belongs to and a struct
      <parameter>change</parameter> describing the row modification are passed
      in.
     </para>
     <note>
      <para>
       Only changes in user defined tables that are not unlogged
       (see <xref linkend="SQL-CREATETABLE-UNLOGGED">) and not temporary
       (see <xref linkend="SQL-CREATETABLE-TEMPORARY">) can be extracted using
       changeset extraction.
      </para>
     </note>
    </sect3>
   </sect2>
   <sect2 id="changesetextraction-output-plugin-output">
    <title>Functions for producing output from an output plugin</title>
    <para>
     To actually produce output, output plugins can write data to
     the <literal>StringInfo</literal> output buffer
     in <literal>ctx-&gt;out</literal> when inside
     the <function>begin_cb</function>, <function>commit_cb</function>
     or <function>change_cb</function> callbacks. Before writing to the output
     buffer <function>OutputPluginPrepareWrite(ctx, last_write)</function> has
     to be called, and after finishing writing to the
     buffer <function>OutputPluginWrite(ctx, last_write)</function> has to be
     called to perform the write. The <parameter>last_write</parameter>
     indicates whether a particular write was the callback's last write.
    </para>
    <para>
     The following example shows how to output data to the consumer of an
     output plugin:
     <programlisting>
OutputPluginPrepareWrite(ctx, true);
appendStringInfo(ctx->out, "BEGIN %u", txn->xid);
OutputPluginWrite(ctx, true);
     </programlisting>
    </para>
   </sect2>
  </sect1>
  <sect1 id="changesetextraction-writer">
   <title>Changeset Extraction Output Writers</title>
   <para>
    It is possible to add more output methods in addition to the SQL
    and replication protocol variants for consuming changeset extraction
    data. For details look at the implementation of the SQL interface
    functions
    in <filename>src/backend/replication/logical/logicalfuncs.c</filename>.
    Essentially three functions need to be provided, one to read WAL, one to
    prepare writing output and one to write the output
    (see <xref linkend="changesetextraction-output-plugin-output">).
   </para>
  </sect1>
  <sect1 id="changesetextraction-synchronous">
   <title>Synchronous replication support for Changeset Extraction</title>
   <para>
    The Changeset Extraction support in <productname>PostgreSQL</productname>
    may be used to to
    build <link linkend="synchronous-replication">synchronous
    replication</link> solutions with the same user interface as synchronous
    replication for <link linkend="streaming-replication">streaming
    replication</link> if the walsender interface
    (see <xref linkend="changesetextraction-walsender">) is used to stream out
    data. Clients have to send <literal>Standby status update (F)</literal>
    (see <xref linkend="protocol-replication">), just like streaming
    replication clients do.
   </para>
  </sect1>
 </chapter>
